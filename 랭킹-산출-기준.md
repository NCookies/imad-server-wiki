- DB 테이블 join하거나 select 해서 계산
  - 영화 리뷰 수
  - 영화 평점
  - 게시물에 태그된 횟수

- 일주일동안 가장 HOT했던 작품 (TOP 10)
    - 전체 - 영화 / TV / 애니메이션
    - 금주 -  영화 / TV /애니메이션
    

**"HOT"** 하다는 기준을 뭘로 세워야할까? 작품 관련 활동?

해당 작품의 리뷰, 게시글 수를 합치고, 만약 동일할 시 평점이 높은 작품을 우선순위로 둘까?

→ 우선 이렇게 하는걸로.

~~Redis를 사용하여 랭킹을 저장하는 것도 좋은 방법이지만, 휘발성 메모리이기 때문에 서버를 재부팅했을 때 데이터를 잃을 수 있다는 단점이 있다. IMAD에서는 실시간이 아니라 전체기간 / 주간 랭킹을 따지므로 적합하지 않다는 판단이다.~~ 

RDBMS에 저장된 랭킹 테이블을 가지고, 실제로 유저가 보게 될 랭킹 정보를 Redis에 업데이트 한다. 애플리케이션이 실행 될 떄마다, 그리고 일정 주기마다 Redis로 업데이트할 수 있도록 한다.

테이블에서 데이터를 얻어오려면 수 많은 데이터를 읽고, 정렬해야 하기 때문…

### AllTimeScore

- **contents_id**
- contents_type
- score

### AllTimeRanking

- **contents_id**
- contents_type
- contents_title
- contents_poster
- rank
- rank_changed (int)

랭킹 테이블에는 id나 type 말고도 클라이언트에서 사용할 데이터(제목, 포스터, 개요 등)를 미리 넣어두면 좋을 것 같다. `rank_changed`는 전날의 랭크와 비교하여 순위 변동이 얼마나 있었는지 보여주는 데이터이다. 테이블을 갱신하기 전에 비교를 해주고 값을 계산해주자. 만약 기존에 없던 랭킹이라면 절대 사용되지 않을만한 값(Ex. 10000)을 넣어서 랭킹에 새로 진입한 contents라는 것을 보여주자.

랭킹 정보를 redis에 저장하게 해두고, 요청이 날라올 때마다 저 데이터들을 보내주자. 랭킹이 메인화면에 위치해있어서 **자주 쓰이고 유저의 상태에 상관없이 항상 같은 값**을 보내주기 때문. 또한 갱신주기도 특정 시기로 정해져있다. 다만 구현은 일단 DB 조회로 해두고, 추후에 redis 추가해서 구현해주자.

### WeeklyScore

- **contents_id**
- contents_type
- **ref_date**
- score

어떤 날짜에 A라는 작품의 리뷰나 게시글이 작성되었다면, 그 날짜에 있는 A 작품의 score가 1 늘어난다. 

매일 다음과 같은 작업이 수행되어야 한다.

- 최근 7일 동안의 score를 정산하여 콘텐츠 타입별로 랭킹을 산출한다.
- 7일 이상 경과한 데이터는 삭제한다.

### WeeklyRanking

- contents_id
- contents_type
- contents_title
- contents_poster
- rank
- rank_changed (int)

이 테이블도 마찬가지로 redis에 저장해서 두고두고 사용해주자.
